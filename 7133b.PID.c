#pragma config(Sensor, dgtl1,  QUAD,           sensorQuadEncoder)
#pragma config(Motor,  port1,           L,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           L1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           BR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           L2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           L3,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           RL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           L4,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FR,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//PID variables setup

#define PID_SENSOR_INDEX   QUAD
#define PID_SENSOR_SCALE   -1

#define PID_MOTOR_INDEX     L1
#define PID_MOTOR_SCALE     1

#define PID_DRIVE_MAX        127
#define PID_DRIVE_MIN		    (-127)

#define PID_INTEGRAL_LIMIT  50
// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"

float  pid_Kp = 2;
float  pid_Ki = 0.04;
float  pid_Kd = 1;

static int   pidRunning = 1;
static float pidRequestedValue;


float  motor_trigger;
float  pidSensorCurrentValue;
float  pidError;
float  pidLastError = 0;
float  pidIntegral = 0;
float  pidDerivative;
float  pidDrive;
float  launchencode1;
float  launchencode2;
float  launchencodefixed;
float  lcdtrigger;
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
  	// Insert user code here.
  	// .....................................................................................
	motor[L1] = 128;
	motor[L2] = -128;					//Launcher command set
	motor[L3] = 128;
	motor[L4] = -128;
	motor[FL] = 127;
	motor[FR] = -120;					//Drive Wheel command set
	motor[BR] = -120;
	motor[BL] = 127;
 	delay(4300);					//Timer
 	{
 		motor[L] = -128;					//Loader Command set
		motor[RL] = 128;
		motor[FL] = 0;
	  motor[FR] = 0;					//Stops drive wheels after certain time
	  motor[BR] = 0;
	  motor[BL] = 0;
	}

	delay(500);
	{
		motor[L] = 0;
		motor[RL] = 0;
	}
		delay(700);
	{
		motor[L] = -128;
		motor[RL] = 128;
	}
		delay(500);
	{
		motor[L] = 0;
		motor[RL] = 0;
	}
		delay(700);
	{
		motor[L] = -128;
		motor[RL] = 128;
	}
		delay(500);
	{
		motor[L] = 0;
		motor[RL] = 0;
	}
		delay(700);
	{
		motor[L] = -128;
		motor[RL] = 128;
	}
  

} // end of autonomous

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
	
	//Create Variables
	int channel3 = 0;
	int channel2 = 0;
	bool button7up = false;
	bool button7down = false;
	bool button7right = false;
	bool button7left = false;
	bool button6up = false;
	bool button6down = false;
	bool button8up = false;
	bool button8down = false;
	bool button8right = false;
	bool button8left = false;
	int speed = 0;
	//int counter = 0; //depreciated
	bool upPressed = false;
	bool downPressed = false;
	launchencode1 = 0;
	launchencode2 = 0;
	pidRequestedValue = 0;
	while (true)
	{
		channel3 = vexRT[Ch3] / 2;
		channel2 = vexRT[Ch2] / 2;
		button7up = (vexRT[Btn7U]==true);
		button7down = (vexRT[Btn7D]==true);
		button7right = (vexRT[Btn7R]==true);
		button7left = (vexRT[Btn7L]==true);
		button6up = (vexRT[Btn6U]==true);
		button6down = (vexRT[Btn6D]==true);
		button8up = (vexRT[Btn8U]==true);
		button8down = (vexRT[Btn8D]==true);
		button8right = (vexRT[Btn8R]==true);
		button8left = (vexRT[Btn8L]==true);
// Permanently leaves LCD backlight on
		bLCDBacklight = true;

		bool toggle = false;
		if (vexRT[Btn8D] == true)
		{
			motor[L] = 127;
		}
		else
		{
			motor[L] = 0;
		}

	motor[FL] = vexRT[Ch3];
	motor[FR] = -vexRT[Ch2];
	motor[BL] = vexRT[Ch3];
	motor[BR] = -vexRT[Ch2];
// Launcher speed change toggles, first 2 old/unused
		if (vexRT[Btn7R]== true)
		{
			toggle = true;
		}
		else if (vexRT[Btn7L] == true)
		{
			toggle = false;
		}
		if (button6up==true)
			{
				upPressed = true;
			}
		 if ((button6up == false) && (upPressed == true))
			{
				pidRequestedValue --;
				speed += 10;      //Raise speed
				upPressed = false;
			}
		 if(button6down==true)
			{
				downPressed = true;     //lower speed
		  }
		 if((button6down == false) && (downPressed == true))
			{
				pidRequestedValue ++;
				speed -= 10;
				downPressed = false;
			}
		 if(button8right==true)
			{
			speed = 0;
			pidRequestedValue = 0; //brake
			}
			if(button8down==true)
			{
				pidRequestedValue = -220;
			}

		wait1Msec(10);

			// pid
		launchencode1 = SensorValue[ QUAD ];
		launchencodefixed = launchencode1 - launchencode2;
    		launchencode2 = launchencode1;

  		if( SensorType[ launchencodefixed ] == sensorQuadEncoder )
        	SensorValue[ launchencodefixed ] = 0;

    	// Init the variables - thanks Glenn :)
    //	pidLastError  = 0; // Check if its initializing every run
    //	pidIntegral   = 0;

        	// Is PID control active ?
        	if( pidRunning )
            	{
            	// Read the sensor value and scale
            	pidSensorCurrentValue = launchencodefixed * PID_SENSOR_SCALE;

            	// calculate error
            	pidError = pidSensorCurrentValue - pidRequestedValue;

            	// integral - if Ki is not 0
            	if( pid_Ki != 0 )
                {
                // If we are inside controlable window then integrate the error
                if( abs(pidIntegral) < PID_INTEGRAL_LIMIT )
                    pidIntegral = pidIntegral + pidError;
                else
                    pidIntegral = PID_INTEGRAL_LIMIT; // changed to PID_INTEGRAL_LIMIT from 0
                }
            else
                pidIntegral = 0;

            // calculate the Derivative
            pidDerivative = pidError - pidLastError;
            pidLastError  = pidError;

            // calculate drive
            pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

            // limit drive
            if( pidDrive > PID_DRIVE_MAX )
                pidDrive = PID_DRIVE_MAX;
            if( pidDrive < PID_DRIVE_MIN )
                pidDrive = PID_DRIVE_MIN;

            // send to motor
            motor_trigger = pidDrive * PID_MOTOR_SCALE;
            }
        else
            {
            // clear all
            pidError      = 0;
            pidLastError  = 0;
            pidIntegral   = 0;
            pidDerivative = 0;
            motor_trigger = 0;
            }
        // Run at 60Hz
        wait1Msec( 10 );




//Launcher speed bindings
					//use speed if pid fails
				motor[L1] = motor_trigger;
 				motor[L2] = -motor_trigger;
 				motor[L3] = motor_trigger;
 				motor[L4] = -motor_trigger;
// Chain drive code
		if (vexRT[Btn5U] == true)
		{
			motor[RL] = 127;
		}
		else if (vexRT[Btn8U] == true)
		{
			motor[RL] = -127;
		}
		else
		{
			motor[RL] = 0;
}
// Belt drive code
		if (vexRT[Btn5D] == true)
		{
			motor[L] = -127;
		}
		else if (vexRT[Btn8L] == true)
		{
			motor[L] = 127;
		}
		else
		{
			motor[L] = 0;
		}
if (lcdtrigger >= 6)
{
	// LCD/Battery Info
	string mainBattery, backupBattery;
	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD
	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);
	displayLCDString(1, 0, "ROBOHAWKS 7133B");
}
else
{
	lcdtrigger ++;
}
wait1Msec(20);
}
}
